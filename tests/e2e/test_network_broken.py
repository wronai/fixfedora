"""
Testy e2e â€“ scenariusz uszkodzonej sieci.
Symuluje: NetworkManager failed, DNS broken, rfkill blocked, firewall issues.
"""

from __future__ import annotations

import os
from unittest.mock import MagicMock, patch

import pytest

from fixos.utils.anonymizer import anonymize


@pytest.fixture
def broken_network_diagnostics():
    """Dane diagnostyczne symulujÄ…ce uszkodzonÄ… sieÄ‡."""
    return {
        "system": {
            "kernel": "6.8.9-300.fc40.x86_64",
            "os_release": "NAME=Fedora\nVERSION=40\nID=fedora",
            "systemctl_failed": (
                "  NetworkManager.service  loaded failed failed Network Manager\n"
                "  systemd-resolved.service  loaded failed failed Network Name Resolution"
            ),
            "journal_errors_24h": (
                "NetworkManager[1234]: <error> device (wlan0): Couldn't initialize supplicant\n"
                "systemd-resolved[5678]: Failed to start DNS stub listener\n"
                "kernel: rfkill: input handler disabled"
            ),
            "firewall": "not running",
        },
        "network": {
            "nm_status": "[ERR]: Failed to connect to system bus: No such file or directory",
            "ip_addr": "[ERR]: Cannot open network namespace: No such file or directory",
            "dns_resolve": "[ERR]: Temporary failure in name resolution",
            "rfkill_list": "0: phy0: Wireless LAN\n\tSoft blocked: yes\n\tHard blocked: no",
            "ping_gateway": "[ERR]: connect: Network is unreachable",
            "wifi_scan": "[ERR]: Error: No Wi-Fi device found",
            "nm_connections": "(brak outputu)",
        },
        "hardware": {
            "dmi_product": "Yoga 7 14ARB7",
            "dmi_vendor": "LENOVO",
            "wifi_device": "Intel Wi-Fi 6 AX200",
        },
    }


@pytest.fixture
def broken_dns_diagnostics():
    """Dane diagnostyczne z problemem tylko DNS."""
    return {
        "system": {
            "kernel": "6.8.9-300.fc40.x86_64",
            "os_release": "NAME=Ubuntu\nVERSION=22.04\nID=ubuntu",
            "systemctl_failed": "  systemd-resolved.service  loaded failed failed",
        },
        "network": {
            "nm_status": "NetworkManager is running",
            "dns_resolve": "[ERR]: Temporary failure in name resolution",
            "resolv_conf": "# Generated by resolvconf\nnameserver 127.0.0.53",
            "systemd_resolved": "â— systemd-resolved.service\n   Active: failed (Result: exit-code)",
        },
    }


class TestNetworkProblemsDetection:
    """Testy wykrywania problemÃ³w sieciowych z danych diagnostycznych."""

    def test_detect_networkmanager_failed(self, broken_network_diagnostics):
        failed = broken_network_diagnostics["system"]["systemctl_failed"]
        assert "NetworkManager" in failed
        assert "failed" in failed.lower()

    def test_detect_dns_failure(self, broken_network_diagnostics):
        dns = broken_network_diagnostics["network"]["dns_resolve"]
        assert "name resolution" in dns.lower() or "ERR" in dns

    def test_detect_rfkill_blocked(self, broken_network_diagnostics):
        rfkill = broken_network_diagnostics["network"]["rfkill_list"]
        assert "Soft blocked: yes" in rfkill

    def test_detect_no_wifi_device(self, broken_network_diagnostics):
        wifi = broken_network_diagnostics["network"]["wifi_scan"]
        assert "ERR" in wifi or "No Wi-Fi" in wifi

    def test_detect_network_unreachable(self, broken_network_diagnostics):
        ping = broken_network_diagnostics["network"]["ping_gateway"]
        assert "unreachable" in ping.lower() or "ERR" in ping

    def test_detect_systemd_resolved_failed(self, broken_dns_diagnostics):
        resolved = broken_dns_diagnostics["network"]["systemd_resolved"]
        assert "failed" in resolved.lower()

    def test_detect_multiple_failed_services(self, broken_network_diagnostics):
        failed = broken_network_diagnostics["system"]["systemctl_failed"]
        assert failed.count("failed") >= 2


class TestNetworkAnonymization:
    """Testy anonimizacji danych sieciowych."""

    def test_ip_in_network_data_masked(self):
        data = "gateway 192.168.1.1 via 10.0.0.1 dev eth0"
        anon, report = anonymize(data)
        assert "192.168.1.1" not in anon
        assert "10.0.0.1" not in anon
        assert report.replacements.get("Adresy IPv4", 0) == 2

    def test_mac_in_network_data_masked(self):
        data = "wlan0: flags=4163 ether aa:bb:cc:dd:ee:ff txqueuelen 1000"
        anon, report = anonymize(data)
        assert "aa:bb:cc:dd:ee:ff" not in anon
        assert "XX:XX:XX:XX:XX:XX" in anon

    def test_hostname_in_network_data_masked(self):
        import socket
        hostname = socket.gethostname()
        data = f"host {hostname} connected to network"
        anon, report = anonymize(data)
        assert hostname not in anon
        assert "[HOSTNAME]" in anon

    def test_private_ip_range_masked(self):
        """Wszystkie prywatne zakresy IP powinny byÄ‡ maskowane."""
        data = "routes: 192.168.0.1, 10.0.0.1, 172.16.0.1"
        anon, report = anonymize(data)
        assert "192.168.0.1" not in anon
        assert "10.0.0.1" not in anon
        assert "172.16.0.1" not in anon
        assert report.replacements.get("Adresy IPv4", 0) == 3


class TestNetworkMockLLM:
    """Testy z mock LLM dla scenariusza broken-network."""

    @patch("fixos.providers.llm.openai")
    def test_llm_suggests_rfkill_unblock(
        self, mock_openai, broken_network_diagnostics, mock_config
    ):
        """LLM powinien sugerowaÄ‡ odblokowanie rfkill."""
        from fixos.providers.llm import LLMClient

        mock_resp = MagicMock()
        mock_resp.choices[0].message.content = (
            "â”â”â” DIAGNOZA â”â”â”\n"
            "ðŸ”´ Problem 1: WiFi zablokowany przez rfkill\n"
            "   **Komenda:** `rfkill unblock wifi`\n"
            "   **Co robi:** Odblokowuje kartÄ™ WiFi\n"
            "ðŸ”´ Problem 2: NetworkManager failed\n"
            "   **Komenda:** `sudo systemctl restart NetworkManager`\n"
            "   **Co robi:** Restartuje NetworkManager\n"
            "ðŸŸ¡ Problem 3: DNS nie dziaÅ‚a\n"
            "   **Komenda:** `sudo systemctl restart systemd-resolved`\n"
            "   **Co robi:** Restartuje resolver DNS\n"
        )
        mock_resp.usage.total_tokens = 200
        mock_openai.OpenAI.return_value.chat.completions.create.return_value = mock_resp

        client = LLMClient(mock_config)
        anon_str, _ = anonymize(str(broken_network_diagnostics))
        reply = client.chat([{"role": "user", "content": anon_str}])

        assert "rfkill" in reply.lower()
        assert "NetworkManager" in reply or "networkmanager" in reply.lower()

    @patch("fixos.providers.llm.openai")
    def test_llm_suggests_dns_fix(
        self, mock_openai, broken_dns_diagnostics, mock_config
    ):
        """LLM powinien sugerowaÄ‡ naprawÄ™ DNS."""
        from fixos.providers.llm import LLMClient

        mock_resp = MagicMock()
        mock_resp.choices[0].message.content = (
            "ðŸ”´ Problem: systemd-resolved failed\n"
            "   **Komenda:** `sudo systemctl restart systemd-resolved`\n"
            "   **Co robi:** Restartuje resolver DNS\n"
            "   **Komenda:** `sudo ln -sf /run/systemd/resolve/stub-resolv.conf /etc/resolv.conf`\n"
            "   **Co robi:** Naprawia symlink resolv.conf\n"
        )
        mock_resp.usage.total_tokens = 150
        mock_openai.OpenAI.return_value.chat.completions.create.return_value = mock_resp

        client = LLMClient(mock_config)
        anon_str, _ = anonymize(str(broken_dns_diagnostics))
        reply = client.chat([{"role": "user", "content": anon_str}])

        assert "systemd-resolved" in reply or "dns" in reply.lower()

    @patch("fixos.providers.llm.openai")
    def test_llm_network_commands_no_sudo_for_rfkill(
        self, mock_openai, broken_network_diagnostics, mock_config
    ):
        """rfkill unblock nie wymaga sudo."""
        from fixos.providers.llm import LLMClient
        from fixos.orchestrator.executor import CommandExecutor

        mock_resp = MagicMock()
        mock_resp.choices[0].message.content = (
            "**Komenda:** `rfkill unblock wifi`\n"
            "**Komenda:** `sudo systemctl restart NetworkManager`\n"
        )
        mock_resp.usage.total_tokens = 80
        mock_openai.OpenAI.return_value.chat.completions.create.return_value = mock_resp

        client = LLMClient(mock_config)
        reply = client.chat([{"role": "user", "content": "fix network"}])

        ex = CommandExecutor(dry_run=True)
        assert ex.needs_sudo("rfkill unblock wifi") is False
        assert ex.needs_sudo("systemctl restart NetworkManager") is True


class TestNetworkExecutorIntegration:
    """Testy integracji executor + network commands."""

    def test_systemctl_user_network_no_sudo(self):
        """systemctl --user dla usÅ‚ug sieciowych nie dostaje sudo."""
        from fixos.orchestrator.executor import CommandExecutor
        ex = CommandExecutor(dry_run=True)
        assert ex.needs_sudo("systemctl --user restart pipewire-pulse") is False

    def test_networkmanager_restart_gets_sudo(self):
        from fixos.orchestrator.executor import CommandExecutor
        ex = CommandExecutor(dry_run=True)
        cmd = ex.add_sudo("systemctl restart NetworkManager")
        assert cmd.startswith("sudo")

    def test_ip_command_no_sudo(self):
        from fixos.orchestrator.executor import CommandExecutor
        ex = CommandExecutor(dry_run=True)
        assert ex.needs_sudo("ip addr show") is False

    def test_rfkill_no_sudo(self):
        from fixos.orchestrator.executor import CommandExecutor
        ex = CommandExecutor(dry_run=True)
        assert ex.needs_sudo("rfkill unblock wifi") is False

    def test_firewall_cmd_needs_sudo(self):
        from fixos.orchestrator.executor import CommandExecutor
        ex = CommandExecutor(dry_run=True)
        assert ex.needs_sudo("firewall-cmd --add-service=http") is True


class TestNetworkRealLLM:
    """Testy z prawdziwym API â€“ tylko gdy token dostÄ™pny."""

    @pytest.mark.skipif(
        not os.environ.get("GEMINI_API_KEY") or "TWOJ" in os.environ.get("GEMINI_API_KEY", ""),
        reason="Wymaga GEMINI_API_KEY w .env"
    )
    def test_real_llm_analyzes_network(self, broken_network_diagnostics, test_config):
        """Prawdziwy LLM powinien wykryÄ‡ problemy sieciowe."""
        from fixos.providers.llm import LLMClient

        client = LLMClient(test_config)
        anon_str, _ = anonymize(str(broken_network_diagnostics))

        messages = [
            {
                "role": "system",
                "content": (
                    "JesteÅ› diagnostÄ… Linux. "
                    "WymieÅ„ gÅ‚Ã³wne problemy sieciowe i podaj komendy naprawcze."
                ),
            },
            {"role": "user", "content": f"Dane:\n{anon_str[:2000]}"},
        ]

        reply = client.chat(messages, max_tokens=300)

        network_terms = [
            "networkmanager", "network manager", "rfkill", "wifi", "dns",
            "resolved", "sieÄ‡", "poÅ‚Ä…czenie", "network"
        ]
        found = [t for t in network_terms if t in reply.lower()]
        assert len(found) >= 1, (
            f"LLM nie wykryÅ‚ problemÃ³w sieciowych. OdpowiedÅº: {reply[:300]}"
        )
        print(f"\nâœ… LLM wykryÅ‚: {found}\nOdpowiedÅº: {reply[:300]}")
